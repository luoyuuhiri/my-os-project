***首先是fork.c代码***

[![pExN23F.png](https://s21.ax1x.com/2025/05/20/pExN23F.png)](https://imgse.com/i/pExN23F)

***本代码会依次输出value的值为20，35，20，5。进入循环，首先父进程中有wait(NULL)，说明如果子进程不结束，在这里会被卡住；所以一定会先进子进程。在子进程和父进程中，value虽然是全局变量，但是他们的地址是不一样的，所以可以理解为独立的。i=0时，进子进程，value加了15，因此第一个输出的是20；此时子进程未结束，因为有循环，i变成1，子进程此时又分成了两个进程，子子进程和子父进程。和i=0时类似，i=1时会先进入子子进程，value从20加到35，然后输出，所以第二个输出的是35；此时子子进程结束，子父进程解除了wait，输出。因为子父进程的value来自子进程，所以value是20，第三个输出的是20；最后，回到最开始的父进程，value是5，第四个输出的是5。***

***接下来是样例代码。***

***样例代码中，本质上是父进程和子进程依次把x加1，父进程初始化x=1，然后通过写到pipe1[1]里传给pipe1[0]，这样子进程那边就可以通过read读取x=1,子进程通过再加1，x=2，通过write到pipe2[1]里传给pipe2[0]，这时候父进程又能拿到了，以此循环至x=10，这个时候进不去循环了，就结束了***

***最后是独立实验***

[![pExUTqs.png](https://s21.ax1x.com/2025/05/20/pExUTqs.png)](https://imgse.com/i/pExUTqs)

[![pExUHZn.png](https://s21.ax1x.com/2025/05/20/pExUHZn.png)](https://imgse.com/i/pExUHZn)

[![pExUXGT.png](https://s21.ax1x.com/2025/05/20/pExUXGT.png)](https://imgse.com/i/pExUXGT)

***先定义三个函数，然后创建两个管道，为fx和fy每个函数配一个管道。用fork()函数创建子进程和父进程，其中子进程用来函数运算，父进程用来输出结果。在父进程中，因为使用了wait函数，所以子进程一定先运算后才会进行父进程，因此父进程在输出的时候一定已经接收到了运算结果的值。两个管道实现的功能本质是一样的只不过是不同的函数而已。fx返回值存到了res_fx里，fy返回值存到res_fy里，然后最后加一下，就是f(x,y)的值。***