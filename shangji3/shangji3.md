***在示例代码中开了四个终端，使用了2个生产者和2个消费者，先按照生产者->消费者->生产者->消费者的顺序进行了检验，得到了可以满足同步的结论***

***信号量的互斥是通过设置初值为1的二元信号量，p操作信号量减1，若为0则占用进程;v操作加1，唤醒进程***

***信号量的同步是通过设置初值为0的二元信号量，p操作时信号量为0则等待v操作，以此确保进程按特定顺序进行***

***互斥信号量初值为1，表示资源可用;同步信号量初值为0，表示等待触发;信号量大于0时表示剩余可用资源或可触发的资源数，等于0表示资源被占满或无事件发生，但无进程阻塞***

***下面是2生产者2消费者的运行结果***


***第一个生产者***
[![pVpiST1.png](https://s21.ax1x.com/2025/05/27/pVpiST1.png)](https://imgse.com/i/pVpiST1)

***第一个消费者***

[![pVpi9Fx.png](https://s21.ax1x.com/2025/05/27/pVpi9Fx.png)](https://imgse.com/i/pVpi9Fx)

***第二个生产者***

[![pVpiPfK.png](https://s21.ax1x.com/2025/05/27/pVpiPfK.png)](https://imgse.com/i/pVpiPfK)

***第二个消费者***

[![pVpiFSO.png](https://s21.ax1x.com/2025/05/27/pVpiFSO.png)](https://imgse.com/i/pVpiFSO)

***篇幅原因不再展示其他顺序和速率，都可以实现***

***在吸烟者问题中参考了示例代码并进行了修改，下面是运行结果***

[![pVpi11S.jpg](https://s21.ax1x.com/2025/05/27/pVpi11S.jpg)](https://imgse.com/i/pVpi11S)


***核心就是共享内存set_shm()函数，在producer.c里面通过随机数随机产生两个不一样的材料m1m2然后传到共享内存里去，供consumer.c里面检查是否跟自己拥有的材料一致，来实现吸烟者问题***